<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collab Gateway Test Client</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c2c7;
        }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre-wrap;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin: 5px;
            min-width: 200px;
        }
        .connection-controls {
            margin-bottom: 15px;
        }
        .connection-controls label {
            display: inline-block;
            min-width: 100px;
            font-weight: bold;
        }
        .editor-section {
            margin: 20px 0;
        }
        #collaborativeEditor {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 2px solid #007bff;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
        }
        #collaborativeEditor:focus {
            outline: none;
            border-color: #0056b3;
        }
        .editor-status {
            margin-top: 10px;
            padding: 8px;
            background-color: #e9ecef;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .sync-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #6c757d;
        }
        .sync-indicator.syncing {
            background-color: #ffc107;
            animation: pulse 1s infinite;
        }
        .sync-indicator.synced {
            background-color: #28a745;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Collab Gateway Test Client</h1>
        
        <div style="background-color: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
            <h4>Testing Instructions:</h4>
            <ol>
                <li>Start the server with <code>npm run start:dev</code></li>
                <li>Open this page in <strong>two different browser tabs</strong></li>
                <li>Use the same <strong>Session ID</strong> in both tabs (e.g., "test-session-123")</li>
                <li>Click <strong>Connect</strong> in both tabs</li>
                <li>Type in the textarea in Tab A → Tab B should mirror the changes instantly</li>
                <li>Try reloading one tab → it should receive the latest text content</li>
            </ol>
        </div>
        
        <div class="connection-controls">
            <label for="serverUrl">Server URL:</label>
            <input type="text" id="serverUrl" value="http://localhost:3000" placeholder="http://localhost:3000">
            <br>
            <label for="sessionId">Session ID:</label>
            <input type="text" id="sessionId" value="test-session-123" placeholder="Enter session ID to join">
            <br>
            <label for="authToken">Auth Token:</label>
            <input type="text" id="authToken" value="dev-test-token" placeholder="Authentication token">
            <br>
            <button id="connectBtn">Connect</button>
            <button id="disconnectBtn" disabled>Disconnect</button>
        </div>

        <div id="status" class="status disconnected">Disconnected</div>

        <div class="editor-section">
            <h3>Collaborative Editor</h3>
            <textarea id="collaborativeEditor" placeholder="Start typing here... Changes will be synchronized with other clients!" disabled></textarea>
            <div id="editorStatus" class="editor-status">
                <span>Editor: Not connected</span>
                <div id="syncIndicator" class="sync-indicator"></div>
            </div>
        </div>

        <div class="test-controls">
            <h3>Test Actions</h3>
            <button id="pingBtn" disabled>Send Ping</button>
            <input type="text" id="customMessage" placeholder="Custom message" disabled>
            <button id="customBtn" disabled>Send Custom Message</button>
            <br>
            <button id="listRoomsBtn" disabled>List All Rooms (Debug)</button>
        </div>

        <div class="log-section">
            <h3>Connection Log</h3>
            <button id="clearLogBtn">Clear Log</button>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <!-- Use ESM import of Yjs to guarantee Y exists -->
    <script type="module">
        import * as Y from 'https://cdn.skypack.dev/yjs';

        // Binary handling helper
        const asU8 = (d) =>
            d instanceof Uint8Array ? d
            : d instanceof ArrayBuffer ? new Uint8Array(d)
            : ArrayBuffer.isView(d) ? new Uint8Array(d.buffer, d.byteOffset, d.byteLength)
            : new Uint8Array();
        class CollabTestClient {
            constructor() {
                this.socket = null;
                this.isConnected = false;
                this.initializeUI();
                this.token = 'dev-test-token'; // Replace with actual JWT after
                this.currentSessionId = null;
                this.currentUserId = null;
                
                // YJS setup
                this.yDoc = new Y.Doc();
                this.yText = this.yDoc.getText('content');
                this.isUpdatingFromYjs = false;
                this.isApplyingRemote = false;
                this.isRenderingFromY = false;
                this.composing = false;
                this.setupYjsBindings();
            }

            initializeUI() {
                this.serverUrlInput = document.getElementById('serverUrl');
                this.sessionIdInput = document.getElementById('sessionId');
                this.authTokenInput = document.getElementById('authToken');
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.statusDiv = document.getElementById('status');
                this.pingBtn = document.getElementById('pingBtn');
                this.customMessageInput = document.getElementById('customMessage');
                this.customBtn = document.getElementById('customBtn');
                this.listRoomsBtn = document.getElementById('listRoomsBtn');
                this.logDiv = document.getElementById('log');
                this.clearLogBtn = document.getElementById('clearLogBtn');
                
                // Editor elements
                this.editorTextarea = document.getElementById('collaborativeEditor');
                this.editorStatusDiv = document.getElementById('editorStatus');
                this.syncIndicator = document.getElementById('syncIndicator');

                this.connectBtn.addEventListener('click', () => this.connect());
                this.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.pingBtn.addEventListener('click', () => this.sendPing());
                this.customBtn.addEventListener('click', () => this.sendCustomMessage());
                this.listRoomsBtn.addEventListener('click', () => this.listAllRooms());
                this.clearLogBtn.addEventListener('click', () => this.clearLog());
                
                // Editor event listeners
                this.editorTextarea.addEventListener('input', () => this.handleEditorInput());
                this.editorTextarea.addEventListener('selectionchange', () => this.handleSelectionChange());
                
                // IME composition handling
                this.editorTextarea.addEventListener('compositionstart', () => { this.composing = true; });
                this.editorTextarea.addEventListener('compositionend', () => { 
                    this.composing = false; 
                    this.handleEditorInput(); 
                });
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[${timestamp}] ${message}\n`;
                this.logDiv.textContent += logMessage;
                this.logDiv.scrollTop = this.logDiv.scrollHeight;
            }

            setupYjsBindings() {
                // Listen for changes in YJS document and update textarea
                this.yText.observe(() => {
                    if (!this.isUpdatingFromYjs) {
                        const currentSelection = {
                            start: this.editorTextarea.selectionStart,
                            end: this.editorTextarea.selectionEnd
                        };
                        
                        this.isRenderingFromY = true;
                        this.editorTextarea.value = this.yText.toString();
                        this.isRenderingFromY = false;
                        
                        // Restore cursor position
                        this.editorTextarea.setSelectionRange(currentSelection.start, currentSelection.end);
                        this.updateEditorStatus(`Document updated (${this.yText.length} chars)`, 'synced');
                    }
                });

                // Listen for document updates to send to other clients
                this.yDoc.on('update', (update) => {
                    if (!this.socket || !this.isConnected) return;
                    if (this.isApplyingRemote) return;                 // <- crucial: don’t echo remotes

                    this.updateEditorStatus(`Sending update...`, 'syncing');
                    this.socket.emit('collab:update', update);         // raw binary
                    this.log(`Sent YJS update: ${update.byteLength ?? update.length} bytes`);

                    setTimeout(() => this.updateEditorStatus(`Synced (${this.yText.length} chars)`, 'synced'), 100);
                    });
            }

            handleEditorInput = () => {
                if (this.isRenderingFromY || this.composing) return;

                const text = this.editorTextarea.value;
                const current = this.yText.toString();
                if (text === current) return;

                this.yDoc.transact(() => {
                    this.yText.delete(0, this.yText.length);
                    if (text.length) this.yText.insert(0, text);
                });
                this.updateEditorStatus(`Local change: ${text.length} chars`, 'syncing');
            };


            handleSelectionChange() {
                // Placeholder for cursor/selection awareness
                const start = this.editorTextarea.selectionStart;
                const end = this.editorTextarea.selectionEnd;
                // Could send awareness updates here for collaborative cursors
            }

            updateEditorStatus(message, syncStatus = 'idle') {
                this.editorStatusDiv.querySelector('span').textContent = `Editor: ${message}`;
                
                // Update sync indicator
                this.syncIndicator.className = 'sync-indicator';
                if (syncStatus === 'syncing') {
                    this.syncIndicator.classList.add('syncing');
                } else if (syncStatus === 'synced') {
                    this.syncIndicator.classList.add('synced');
                }
            }

            updateStatus(connected, message = '') {
                this.isConnected = connected;
                this.statusDiv.className = `status ${connected ? 'connected' : 'disconnected'}`;
                
                if (connected) {
                    const sessionInfo = this.currentSessionId ? ` | Session: ${this.currentSessionId}` : '';
                    const userInfo = this.currentUserId ? ` | User: ${this.currentUserId}` : '';
                    this.statusDiv.textContent = `Connected ${message}${sessionInfo}${userInfo}`;
                    this.connectBtn.disabled = true;
                    this.disconnectBtn.disabled = false;
                    this.pingBtn.disabled = false;
                    this.customMessageInput.disabled = false;
                    this.customBtn.disabled = false;
                    this.listRoomsBtn.disabled = false;
                    this.sessionIdInput.disabled = true;
                    this.authTokenInput.disabled = true;
                    this.editorTextarea.disabled = false;
                    this.updateEditorStatus('Ready for collaboration');
                } else {
                    this.statusDiv.textContent = `Disconnected ${message}`;
                    this.connectBtn.disabled = false;
                    this.disconnectBtn.disabled = true;
                    this.pingBtn.disabled = true;
                    this.customMessageInput.disabled = true;
                    this.customBtn.disabled = true;
                    this.listRoomsBtn.disabled = true;
                    this.sessionIdInput.disabled = false;
                    this.authTokenInput.disabled = false;
                    this.editorTextarea.disabled = true;
                    this.currentSessionId = null;
                    this.currentUserId = null;
                    this.updateEditorStatus('Not connected');
                }
            }

            connect() {
                const serverUrl = this.serverUrlInput.value;
                const sessionId = this.sessionIdInput.value.trim();
                const token = this.authTokenInput.value.trim();
                
                if (!sessionId) {
                    this.log('Error: Session ID is required');
                    return;
                }
                
                if (!token) {
                    this.log('Error: Auth token is required');
                    return;
                }
                
                this.log(`Attempting to connect to ${serverUrl}/collab with session ID: ${sessionId} and token: ${token}`);

                try {
                    this.socket = io(`${serverUrl}/collab`, {
                        transports: ['websocket'],
                        auth: {
                            token: token,
                            sessionId: sessionId
                        },
                        forceNew: true
                    });

                    this.socket.on('connect', () => {
                        this.log(`Connected with socket ID: ${this.socket.id}`);
                        this.updateStatus(true, `(ID: ${this.socket.id})`);
                    });

                    // Listen for successful session join
                    this.socket.on('collab:connected', (data) => {
                        this.log(`Successfully joined session: ${JSON.stringify(data)}`);
                        this.currentUserId = data.userId;
                        this.currentSessionId = data.sessionId;
                        this.updateStatus(true, `(ID: ${this.socket.id})`);
                    });

                    // Listen for session join errors
                    this.socket.on('collab:error', (error) => {
                        this.log(`Session error: ${JSON.stringify(error)}`);
                        this.updateStatus(false, '- Session Error');
                    });

                    this.socket.on('disconnect', (reason) => {
                        this.log(`Disconnected. Reason: ${reason}`);
                        this.updateStatus(false, `(${reason})`);
                    });

                    this.socket.on('connect_error', (error) => {
                        this.log(`Connection error: ${error.message}`);
                        this.updateStatus(false, '- Connection Error');
                    });

                    // Listen for pong responses
                    this.socket.on('pong', (data) => {
                        this.log(`Received pong: ${JSON.stringify(data)}`);
                    });

                    // Listen for YJS state synchronization
                    this.socket.on('collab:state', (payload) => {
                        const state = asU8(payload);
                        this.log(`Received initial state: ${state.byteLength} bytes`);
                        this.isApplyingRemote = true;
                        try {
                            Y.applyUpdate(this.yDoc, state);
                            // No manual textarea.value here—observe() will render.
                            this.updateEditorStatus(`Synced with server (${this.yText.length} chars)`, 'synced');
                        } catch (e) {
                            this.log(`Error applying initial state: ${e.message}`);
                        }
                        this.isApplyingRemote = false;
                    });

                    // Listen for YJS updates from other clients
                    this.socket.on('collab:update', (payload) => {
                        const update = asU8(payload);
                        this.log(`Received YJS update: ${update.byteLength} bytes`);
                        this.isApplyingRemote = true;
                        try {
                            Y.applyUpdate(this.yDoc, update);
                            // No manual textarea.value here—observe() will render.
                            this.updateEditorStatus(`Update from peer (${this.yText.length} chars)`, 'synced');
                        } catch (e) {
                            this.log(`Error applying update: ${e.message}`);
                        }
                        this.isApplyingRemote = false;
                    });

                    // Listen for awareness updates (collaborative cursors/selections)
                    this.socket.on('collab:awareness', (awarenessArray) => {
                        // Placeholder for collaborative cursors
                        this.log(`Received awareness update: ${awarenessArray.length} bytes`);
                    });

                    // Listen for any other events
                    this.socket.onAny((eventName, ...args) => {
                        if (!['pong', 'collab:connected', 'collab:error', 'collab:state', 'collab:update', 'collab:awareness'].includes(eventName)) {
                            this.log(`Received event '${eventName}': ${JSON.stringify(args)}`);
                        }
                    });

                } catch (error) {
                    this.log(`Error creating socket: ${error.message}`);
                    this.updateStatus(false, '- Error');
                }
            }

            disconnect() {
                if (this.socket) {
                    this.socket.disconnect();
                    this.socket = null;
                }
                // Reset YJS document for new session
                this.yDoc.destroy();
                this.yDoc = new Y.Doc();
                this.yText = this.yDoc.getText('content');
                this.setupYjsBindings();
                this.editorTextarea.value = '';
                this.updateStatus(false);
            }

            sendPing() {
                if (this.socket && this.isConnected) {
                    const pingData = { 
                        timestamp: Date.now(), 
                        message: 'Test ping from web client' 
                    };
                    this.log(`Sending ping: ${JSON.stringify(pingData)}`);
                    this.socket.emit('ping', pingData);
                } else {
                    this.log('Cannot send ping - not connected');
                }
            }

            sendCustomMessage() {
                if (this.socket && this.isConnected) {
                    const message = this.customMessageInput.value.trim();
                    if (message) {
                        const customData = {
                            type: 'custom',
                            message: message,
                            timestamp: Date.now()
                        };
                        this.log(`Sending custom message 'ping': ${JSON.stringify(customData)}`);
                        this.socket.emit('ping', customData);
                        this.customMessageInput.value = '';
                    }
                } else {
                    this.log('Cannot send message - not connected');
                }
            }

            listAllRooms() {
                if (this.socket && this.isConnected) {
                    this.log('Requesting list of all rooms...');
                    this.socket.emit('collab:listAllRooms');
                } else {
                    this.log('Cannot list rooms - not connected');
                }
            }

            clearLog() {
                this.logDiv.textContent = '';
            }
        }

        // Initialize the test client when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new CollabTestClient();
        });
    </script>
</body>
</html>